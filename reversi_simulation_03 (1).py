# -*- coding: utf-8 -*-
"""reversi simulation 03.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14YLPIi_W9gwcmVWtR0VdWyFaaw0oIV2o

# Board
"""

import random
import sys

def newBoard():
  board = []
  for i in range(8):
    board.append([' '] * 8)
  return board

def setBoard(board):
	for x in range(8):
		for y in range(8):
			board[x][y] = ' '

	board[3][3] = 'X'
	board[3][4] = 'O'
	board[4][3] = 'O'
	board[4][4] = 'X'
	return board

def drawBoard(board):
	h = '  +---+---+---+---+---+---+---+---+'
	v = '  |   |   |   |   |   |   |   |   |'
	print('')
	print('   1   2   3   4   5   6   7   8')
	print(h)
	for x in range(8):
		print(v)
		print(x+1, end=' ')
		for y in range(8):
			# print('| %s' % (board[y][x]), end=' ')
			print('| '+ board[y][x], end=' ')
		print('|')
		print(v)
		print(h)
	return board

def boardCopy(board):
  dupeBoard = board.copy()
  return dupeBoard

def onBoard(x, y):
	return x >= 0 and x <= 7 and y >= 0 and y <=7

def corner(x, y):
	return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)

Board = newBoard()
setBoard(Board)

drawBoard(Board)

"""# ValidMove"""

def validMove(board, tile, xstart, ystart):
	if board[xstart][ystart] != ' ' or not onBoard(xstart, ystart):
		return False

	board[xstart][ystart] = tile

	if tile == 'X':
		otherTile = 'O'
	else:
		otherTile = 'X'

	tilesToFlip = []
	for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:
		x, y = xstart, ystart
		x += xdirection
		y += ydirection
		if isOnBoard(x, y) and board[x][y] == otherTile:

			x += xdirection
			y += ydirection
			if not isOnBoard(x, y):
				continue
			while board[x][y] == otherTile:
				x += xdirection
				y += ydirection
				if not isOnBoard(x, y):
					break
			if not isOnBoard(x, y):
				continue
			if board[x][y] == tile:
				while True:
					x -= xdirection
					y -= ydirection
					if x == xstart and y == ystart:
						break
					tilesToFlip.append([x, y])

	board[xstart][ystart] = ' '
	if len(tilesToFlip) == 0:
		return False
	return tilesToFlip

def getValidMoves(board, tile):
	validMoves = []

	for x in range(8):
		for y in range(8):
			if isValidMove(board, tile, x, y) != False:
				validMoves.append([x, y])
	return validMoves
def getBoardWithValidMoves(board, tile):
	dupeBoard = getBoardCopy(board)

	for x, y in getValidMoves(dupeBoard, tile):
		dupeBoard[x][y] = '.'
	return dupeBoard

"""# '-1,-1' ' 0,-1' ' 1,-1'
# '-1, 0' ' 0, 0' ' 1, 0'
# '-1, 1' ' 0, 1' ' 1, 1'

# score
"""

def getScoreOfBoard(board):
	xscore = 0
	oscore = 0
	for x in range(8):
		for y in range(8):
			if board[x][y] == 'X':
				xscore += 1
			if board[x][y] == 'O':
				oscore += 1
	return {'X':xscore, 'O':oscore}

def showPoints(playerTile, computerTile):
	scores = getScoreOfBoard(mainBoard)
	print('You have %s points. The computer has %s points.' % (scores[playerTile], scores[computerTile]))

"""# move"""

def getPlayerMove(board, playerTile):
	DIGITS1TO8 = '1 2 3 4 5 6 7 8'.split()
	while True:
		print('Enter your move, or type quit to end the game.')
		move = input().lower()
		if move == 'quit':
			return 'quit'
		if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:
			x = int(move[0]) - 1
			y = int(move[1]) - 1
			if isValidMove(board, playerTile, x, y) == False:
				continue
			else:
				break
		else:
			print('That is not a valid move. Type the x digit (1-8), then the y digit (1-8).')
			print('For example, 81 will be the top-right corner.')

	return [x, y]
def makeMove(board, tile, xstart, ystart):
	tilesToFlip = isValidMove(board, tile, xstart, ystart)

	if tilesToFlip == False:
		return False

	board[xstart][ystart] = tile
	for x, y in tilesToFlip:
		board[x][y] = tile
	return True

def getComputerMove(board, computerTile):
	possibleMoves = getValidMoves(board, computerTile)
 
	for x, y in possibleMoves:
		if corner(x, y):
			return [x, y]

	bestScore = -1
	for x, y in possibleMoves:
		dupeBoard = getBoardCopy(board)
		makeMove(dupeBoard, computerTile, x, y)
		score = getScoreOfBoard(dupeBoard)[computerTile]
		if score > bestScore:
			bestMove = [x, y]
			bestScore = score
	return bestMove

def enterPlayerTile():
	tile = ''
	while not (tile == 'X' or tile == 'O'):
		print('Do you want to be X or O?')
		tile = input().upper()

	if tile == 'X':
		return ['X', 'O']
	else:
		return ['O', 'X']


def whoGoesFirst():
	if random.randint(0, 1) == 0:
		return 'computer'
	else:
		return 'player'


def playAgain():
	print('Do you want to play again? (yes or no)')
	return input().lower().startswith('y')

"""# Game"""

print('Welcome to Reversi!')

while True:
	mainBoard = newBoard()
	setBoard(mainBoard)
	playerTile, computerTile = enterPlayerTile()
	turn = whoGoesFirst()
	print('The ' + turn + ' will go first.')

	while True:
		if turn == 'player':
			drawBoard(mainBoard)
			showPoints(playerTile, computerTile)
			move = getPlayerMove(mainBoard, playerTile)
			if move == 'quit':
				print('Thanks for playing!')
				sys.exit()
			else:
				makeMove(mainBoard, playerTile, move[0], move[1])

			if getValidMoves(mainBoard, computerTile) == []:
				break
			else:
				turn = 'computer'

		else:
			drawBoard(mainBoard)
			showPoints(playerTile, computerTile)
			x, y = getComputerMove(mainBoard, computerTile)
			makeMove(mainBoard, computerTile, x, y)

			if getValidMoves(mainBoard, playerTile) == []:
				break
			else:
				turn = 'player'

	drawBoard(mainBoard)
	scores = getScoreOfBoard(mainBoard)
	print('X scored %s points. O scored %s points.' % (scores['X'], scores['O']))
	if scores[playerTile] > scores[computerTile]:
		print('You beat the computer by %s points! Congratulations!' % (scores[playerTile] - scores[computerTile]))
	elif scores[playerTile] < scores[computerTile]:
		print('You lost. The computer beat you by %s points.' % (scores[computerTile] - scores[playerTile]))
	else:
		print('The game was a tie!')

	if not playAgain():
		break